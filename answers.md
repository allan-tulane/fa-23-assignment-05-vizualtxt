# CMPS 2200 Assignment 5
## Answers

**Name:** Ali Sulehria



- **1a.**

  The maximum depth of the d-ary tree is ceil(log_d(n)), the generalized form of the expression for binary tree depth

- **1b.**

  For 'delete-min', the operation compares a node to all of its children at each level. Given the depth log_d(n), and a maximum number of nodes d at a given level, its work is on the order of O(d*log_d(n))

  'insert' will still compare at each level, but not to each node in the level. As such, the O(d) term disappears, and the work for 'insert' is of O(log_d(n))

- **1c.**

  As 'delete-min's work dominates relative to insert, we will consider it for this question. Both terms will be based on |V|, and one should have d to reflect 'delete-min'. This produces:
  
  O(d|V|*log_d(|V|) + |E|*log_d(|V|))

- **1d.**
- 
- //here, assume |E| = E and |V| = V, for conciseness. and epsilon = eps

  if our work is O(|E|), then d|V|*log_d(|V|) + |E| x log_d(|V|) = |E|.
  We isolate the first term, as it dominates and will be the primary influence on runtime.
  So, if we substitute |V|^(1+eps) for |E|, then we get:
    dV x log_d(V) = V^(1+eps)
    **dlog_d(V) = V^eps**
  With this, we obtain an expression for the maximum value of d which will result in a runtime of O(|E|).
  

- **2a.**

  APSP(0,0,x) = APSP(1,1,x) = APSP(2,2,x) = 0
  for k = 0:
  APSP(0,1,0) = -2; APSP(1,0,0) = -2; APSP(2,0,0) = 2;
  APSP(2,1,0) = 0; APSP(0,2,0) = 2; APSP(1, 2, 0) = 0

  for k  = 1:
  APSP(0,1,1) = -2; APSP(1,0,1) = -2; APSP(0,2,1) = -1;
  APSP(2,0,1) = -1; APSP(2,1,1) = 0; APSP(1,2,1) = 0

  for k = 2:
  APSP(0,1,2) = APSP(1,0,2) = -2; APSP (2,0,2) = APSP(0,2,2) = -1;
  APSP(1,2,2) = APSP(2,1,2) = 0;

- **2b.**

  APSP(i,j,2) = APSP(i,j,1)

- **2c.**

  APSP(i,j,k) = min(APSP(i,j,k-1), APSP(i,k,k-1), APSP(j,k,k-1))

- **2d.**

  For n vertices, we have n^2 pairs with O(n) work at each. Thus, to naively calculate the shortest paths, there are n^3 subproblems.
  The work of the algorithm overall is of the order O(n^3).

- **2e.**

  For Johnson's algorithm, we have a work of O(|V| x |E|log(|E|)), so our algorithm is preferable when n^3 < |V| x |E|log(|E|)

- **3a.**

  No, as the MST is inherently a greedy algorithm, not considering the weights by path, rather just taking the problem globally. Some paths may have inordinately high weights, even though the global weight is minimized. MMET, in contrast, *does* focus on reducing the individual max edge weights and thus will produce a tree with optimal subproblems.

- **3b.**

  Sort all edges in increasing order by weight.
  For each edge in the list:
    Exclude this edge.
    Find a tree with the remaining edges using MST.
    Calulate the weight and reinsert the edge back into the list.
  Select the tree with the second lowest weight (first is the one
  generated by MST)  

- **3c.**

  The work of the algorithm should be identical to Prim's algorithm,   given that the modifications only change the work in constant time. So:
  W(n) = O(|E|log(|E|))
  